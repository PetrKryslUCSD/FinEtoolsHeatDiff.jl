<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · FinEtoolsHeatDiff.jl</title><meta name="title" content="Guide · FinEtoolsHeatDiff.jl"/><meta property="og:title" content="Guide · FinEtoolsHeatDiff.jl"/><meta property="twitter:title" content="Guide · FinEtoolsHeatDiff.jl"/><meta name="description" content="Documentation for FinEtoolsHeatDiff.jl."/><meta property="og:description" content="Documentation for FinEtoolsHeatDiff.jl."/><meta property="twitter:description" content="Documentation for FinEtoolsHeatDiff.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FinEtoolsHeatDiff.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Modules"><span>Modules</span></a></li><li><a class="tocitem" href="#Heat-conduction-FEM-machines"><span>Heat  conduction FEM machines</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><span class="tocitem">Types and Functions</span><ul><li><a class="tocitem" href="../../man/man/">Manual</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/main/docs/src/guide/guide.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Guide"><a class="docs-heading-anchor" href="#Guide">Guide</a><a id="Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Guide" title="Permalink"></a></h1><p>The <a href="https://petrkryslucsd.github.io/FinEtools.jl/latest/index.html"><code>FinEtools</code></a> package is used here to solve heat conduction problems.</p><p>Tutorials  are provided in the form of Julia scripts and Markdown files in a dedicated folder: <a href="https://github.com/PetrKryslUCSD/FinEtoolsHeatDiff.jl/blob/main/tutorials/index.md"><code>index of tutorials</code></a>. </p><h2 id="Modules"><a class="docs-heading-anchor" href="#Modules">Modules</a><a id="Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Modules" title="Permalink"></a></h2><p>The package <code>FinEtoolsHeatDiff</code> has the following structure:</p><ul><li><p><strong>Top-level</strong>:    <code>FinEtoolsHeatDiff</code> is the  top-level module.</p></li><li><p><strong>Heat conduction</strong>: <code>AlgoHeatDiffModule</code> (algorithms), <code>FEMMHeatDiffModule</code>, <code>FEMMHeatDiffSurfModule</code>  (FEM machines  to evaluate  the  matrix and vector quantities), <code>MatHeatDiffModule</code>  (heat diffusion material)</p></li></ul><h2 id="Heat-conduction-FEM-machines"><a class="docs-heading-anchor" href="#Heat-conduction-FEM-machines">Heat  conduction FEM machines</a><a id="Heat-conduction-FEM-machines-1"></a><a class="docs-heading-anchor-permalink" href="#Heat-conduction-FEM-machines" title="Permalink"></a></h2><p>There is one for  the interior integrals  and one for the boundary integrals. The  machine for the interior integrals can be used to compute:</p><ul><li><p>Conductivity matrix.</p></li><li><p>Load vector corresponding to prescribed temperature.</p></li></ul><p>The machine for the boundary integrals can be used to compute:</p><ul><li><p>Surface heat transfer  matrix.</p></li><li><p>Heat load vector for surface heat transfer.</p></li></ul><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><p>Solution procedures and other  common operations on FEM models  are expressed  in algorithms. Anything that algorithms can do,  the user of FinEtools  can do manually, but to use an algorithm is convenient.</p><p>Algorithms typically (not always) accept a single argument, <code>modeldata</code>, a dictionary of data, keyed by Strings. Algorithms  also return <code>modeldata</code>,  typically  including additional key/value pairs that represent the data computed by the algorithm.</p><h3 id="Heat-diffusion-algorithms"><a class="docs-heading-anchor" href="#Heat-diffusion-algorithms">Heat diffusion algorithms</a><a id="Heat-diffusion-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Heat-diffusion-algorithms" title="Permalink"></a></h3><p>There is an implementation of an algorithm for steady-state heat conduction.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Two-dimensional-heat-transfer-with-convection:-convergence-study."><a class="docs-heading-anchor" href="#Two-dimensional-heat-transfer-with-convection:-convergence-study.">Two-dimensional heat transfer with convection: convergence study.</a><a id="Two-dimensional-heat-transfer-with-convection:-convergence-study.-1"></a><a class="docs-heading-anchor-permalink" href="#Two-dimensional-heat-transfer-with-convection:-convergence-study." title="Permalink"></a></h3><p>Consider a plate of uniform thickness, measuring 0.6 m by 1.0 m. On one short edge the temperature is fixed at 100 °C, and on one long edge the plate is perfectly insulated so that the heat flux is zero through that edge. The other two edges are losing heat via convection to an ambient temperature of 0 °C. The thermal conductivity of the plate is 52.0 W/(m .°K), and the convective heat transfer coefficient is 750 W/(m^2.°K). There is no internal generation of heat. Calculate the temperature 0.2 m along the un-insulated long side, measured from the intersection with the fixed temperature side. The reference result is 18.25 °C.</p><p>The reference temperature at the point A  is 18.25 °C according to the NAFEMS publication (which cites the book Carslaw, H.S. and J.C. Jaeger, Conduction of Heat in Solids. 1959: Oxford University Press).</p><p>The present  tutorial will investigate the reference temperature  and it will attempt to  estimate the  limit value more precisely using a sequence of meshes and Richardson&#39;s extrapolation.</p><p>We begin by defining a few geometric parameters.</p><pre><code class="language-julia hljs">using FinEtools
# Geometrical dimensions
Width = 0.6 * phun(&quot;M&quot;)
Height = 1.0 * phun(&quot;M&quot;)
HeightA = 0.2 * phun(&quot;M&quot;)
Thickness = 0.1 * phun(&quot;M&quot;)
tolerance = Width / 1000</code></pre><p>And now we are ready to define the conductivity of the material.</p><pre><code class="language-julia hljs">using FinEtoolsHeatDiff
# Conductivity matrix
kappa = [52.0 0; 0 52.0] * phun(&quot;W/(M*K)&quot;) 
m = MatHeatDiff(kappa)</code></pre><p>The surface heat transfer coefficient (film coefficient) is also defined,</p><pre><code class="language-julia hljs"># Surface heat transfer coefficient
h = 750 * phun(&quot;W/(M^2*K)&quot;)</code></pre><p>as is the temperature along one edge.</p><pre><code class="language-julia hljs"># Prescribed temperature.
T1 = 100 * phun(&quot;K&quot;)</code></pre><p>Now we are ready to round the simulation five times, for progressively increasing refinement levels, and collect the computed value of the reference quantity.</p><pre><code class="language-julia hljs"># Five progressively refined models will be created and solved. 
modeldata = nothing
resultsTempA = Float64[]
params = Float64[]
for nref in 2:6
    # The mesh is created from two rectangular blocks to begin with.
    fens, fes = T3blockx([0.0, Width], [0.0, HeightA])
    fens2, fes2 = T3blockx([0.0, Width], [HeightA, Height])
    # The meshes are then glued into a single entity.
    fens, newfes1, fes2 = mergemeshes(fens, fes, fens2, fes2, tolerance)
    fes = cat(newfes1, fes2)
    # Refine the mesh desired number of times.
    for ref in 1:nref
        fens, fes = T3refine(fens, fes)
    end
    # The boundary is extracted.
    bfes = meshboundary(fes)
    # The prescribed temperature is applied along edge 1 (the bottom
    # edge in Figure 1).
    list1 = selectnode(fens; box = [0.0 Width 0.0 0.0], inflate = tolerance)
    essential1 = FDataDict(&quot;node_list&quot; =&gt; list1, &quot;temperature&quot; =&gt; T1)
    # The convection (surface heat transfer) boundary condition is applied
    # along the edges 2,3,4. 
    list2 = selectelem(fens, bfes; box = [Width Width 0.0 Height], inflate = tolerance)
    list3 = selectelem(fens, bfes; box = [0.0 Width Height Height], inflate = tolerance)
    # The boundary integrals are evaluated using a surface FEMM.
    cfemm = FEMMHeatDiffSurf(
        IntegDomain(subset(bfes, vcat(list2, list3)), GaussRule(1, 3), Thickness),
        h,
    )
    convection1 = FDataDict(&quot;femm&quot; =&gt; cfemm, &quot;ambient_temperature&quot; =&gt; 0.0)
    # The interior integrals are evaluated using a volume FEMM.
    femm = FEMMHeatDiff(IntegDomain(fes, TriRule(3), Thickness), m)
    region1 = FDataDict(&quot;femm&quot; =&gt; femm)
    # Make the model data
    modeldata = FDataDict(
        &quot;fens&quot; =&gt; fens,
        &quot;regions&quot; =&gt; [region1],
        &quot;essential_bcs&quot; =&gt; [essential1],
        &quot;convection_bcs&quot; =&gt; [convection1],
    )
    # Call the solver
    modeldata = AlgoHeatDiffModule.steadystate(modeldata)
    # Locate the node at the point A  [coordinates (Width,HeightA)].
    list4 = selectnode(fens; box=[Width Width HeightA HeightA], inflate=tolerance)
    # Collect the temperature  at the point A.
    Temp = modeldata[&quot;temp&quot;]
    println(&quot;$(Temp.values[list4][1])&quot;)
    push!(resultsTempA, Temp.values[list4][1])
    push!(params, 1.0 / 2^nref)
end</code></pre><p>The computed results can be processed with Richardson extrapolation to arrive at an estimate of the true solution.</p><pre><code class="language-julia hljs"># These are the computed results for the temperature at point A:
println(&quot;$( resultsTempA  )&quot;)
# Richardson extrapolation can be used to estimate the limit.
solnestim, beta, c, residual = richextrapol(resultsTempA[(end-2):end], params[(end-2):end])
println(&quot;Solution estimate = $(solnestim)&quot;)
println(&quot;Convergence rate estimate  = $(beta)&quot;)</code></pre><p>In order to visualize the results, we export to Paraview. The geometry is two-dimensional: this means we can visualize the temperature as a three dimensional surface raised above the mesh.</p><pre><code class="language-julia hljs"># Postprocessing
geom = modeldata[&quot;geom&quot;]
Temp = modeldata[&quot;temp&quot;]
regions = modeldata[&quot;regions&quot;]
vtkexportmesh(
    &quot;T4NAFEMS--T3-solution.vtk&quot;,
    connasarray(regions[1][&quot;femm&quot;].integdomain.fes),
    [geom.values (Temp.values / 100)],
    FinEtools.MeshExportModule.VTK.T3;
    scalars = [(&quot;Temperature&quot;, Temp.values)],
)
vtkexportmesh(
    &quot;T4NAFEMS--T3-mesh.vtk&quot;,
    connasarray(regions[1][&quot;femm&quot;].integdomain.fes),
    geom.values,
    FinEtools.MeshExportModule.VTK.T3,
)</code></pre><p><img src="../T4NAFEMS--T3-solution.png" alt="Alt Visualization of the temperature field"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../../man/man/">Manual »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 15 March 2025 18:05">Saturday 15 March 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
